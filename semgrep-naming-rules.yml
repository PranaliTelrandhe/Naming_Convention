rules:
  - id: c-strict-naming-combined
    languages: [c]
    message: "Naming violation: '$VAR' must follow the VmedD prefix convention (e.g., b, c, i32, u16, pf, pc, pv, pi, pu)."
    severity: WARNING
    pattern-either:
      # --- BASIC TYPES ---
      - patterns:
          - pattern: bool $VAR;
          - metavariable-regex: { metavariable: $VAR, regex: "^(?!b[A-Z]).*" }
      - patterns:
          - pattern: double $VAR;
          - metavariable-regex: { metavariable: $VAR, regex: "^(?!db[A-Z]).*" }
      - patterns:
          - pattern: float $VAR;
          - metavariable-regex: { metavariable: $VAR, regex: "^(?!fp[A-Z]).*" }

      # --- SIGNED INTEGERS (Bit-Width) ---
      - patterns:
          - pattern-either:
              [{ pattern: int8_t $VAR; }, { pattern: signed char $VAR; }]
          - metavariable-regex: { metavariable: $VAR, regex: "^(?!i8[A-Z]).*" }
      - patterns:
          - pattern-either:
              [{ pattern: int16_t $VAR; }, { pattern: short $VAR; }]
          - metavariable-regex: { metavariable: $VAR, regex: "^(?!i16[A-Z]).*" }
      - patterns:
          - pattern-either: [{ pattern: int32_t $VAR; }, { pattern: int $VAR; }]
          - metavariable-regex: { metavariable: $VAR, regex: "^(?!i32[A-Z]).*" }

      # --- UNSIGNED INTEGERS (Bit-Width) ---
      - patterns:
          - pattern-either:
              [{ pattern: uint8_t $VAR; }, { pattern: unsigned char $VAR; }]
          - metavariable-regex: { metavariable: $VAR, regex: "^(?!u8[A-Z]).*" }
      - patterns:
          - pattern-either:
              [{ pattern: uint16_t $VAR; }, { pattern: unsigned short $VAR; }]
          - metavariable-regex: { metavariable: $VAR, regex: "^(?!u16[A-Z]).*" }
      - patterns:
          - pattern-either:
              [{ pattern: uint32_t $VAR; }, { pattern: unsigned int $VAR; }]
          - metavariable-regex: { metavariable: $VAR, regex: "^(?!u32[A-Z]).*" }

      # --- NON-INTEGER POINTERS ---
      - patterns:
          - pattern: float * $VAR;
          - metavariable-regex: { metavariable: $VAR, regex: "^(?!pf[A-Z]).*" }
      - patterns:
          - pattern: char * $VAR;
          - metavariable-regex: { metavariable: $VAR, regex: "^(?!pc[A-Z]).*" }
      - patterns:
          - pattern: void * $VAR;
          - metavariable-regex: { metavariable: $VAR, regex: "^(?!pv[A-Z]).*" }

      # --- INTEGER POINTERS (pi/pu) ---
      - patterns:
          - pattern-either:
              [{ pattern: int8_t * $VAR; }, { pattern: signed char * $VAR; }]
          - metavariable-regex: { metavariable: $VAR, regex: "^(?!pi8[A-Z]).*" }
      - patterns:
          - pattern-either:
              [{ pattern: int16_t * $VAR; }, { pattern: short * $VAR; }]
          - metavariable-regex:
              { metavariable: $VAR, regex: "^(?!pi16[A-Z]).*" }
      - patterns:
          - pattern-either:
              [{ pattern: int32_t * $VAR; }, { pattern: int * $VAR; }]
          - metavariable-regex:
              { metavariable: $VAR, regex: "^(?!pi32[A-Z]).*" }
      - patterns:
          - pattern-either:
              [{ pattern: uint32_t * $VAR; }, { pattern: unsigned int * $VAR; }]
          - metavariable-regex:
              { metavariable: $VAR, regex: "^(?!pu32[A-Z]).*" }

          # char (used for characters/strings) -> c
      - patterns:
          - pattern: char $VAR;
          - metavariable-regex:
              metavariable: $VAR
              regex: "^(?!c[A-Z]).*"

          #signed char -> i8
      - patterns:
          - pattern: signed char $VAR;
          - metavariable-regex:
              metavariable: $VAR
              regex: "^(?!i8[A-Z]).*"

              #unsigned char -> u8
      - patterns:
          - pattern: unsigned char $VAR;
          - metavariable-regex:
              metavariable: $VAR
              regex: "^(?!u8[A-Z]).*"

          #array -> a
      - patterns:
          - pattern: $TYPE $VAR[...];
          - metavariable-regex:
              metavariable: $VAR
              regex: "^(?!a[A-Z]).*"

        # array of char -> ac
      - patterns:
          - pattern: char $VAR[...];
          - metavariable-regex:
              metavariable: $VAR
              regex: "^(?!ac[A-Z]).*"

          # uint16_t -> u16, uint32_t -> u32, int32_t -> i32
      - patterns:
          - pattern: uint16_t $VAR;
          - metavariable-regex: { metavariable: $VAR, regex: "^(?!u16[A-Z]).*" }
      - patterns:
          - pattern: uint32_t $VAR;
          - metavariable-regex: { metavariable: $VAR, regex: "^(?!u32[A-Z]).*" }
      - patterns:
          - pattern: int32_t $VAR;
          - metavariable-regex: { metavariable: $VAR, regex: "^(?!i32[A-Z]).*" }

     # --- FUNCTION PARAMETERS (Prototypes & Definitions) ---
      
      # 1. Void Pointers (pv)
      
      - patterns:
          - pattern-either:
              - pattern: $TYPE $FUNC(..., void * $VAR, ...);
              - pattern: $TYPE $FUNC(..., void * $VAR, ...) { ... }
          - metavariable-regex:
              metavariable: $VAR
              regex: "^(?!pv[A-Z]).*"

      # 2. Integers (i32)
      - patterns:
          - pattern-either:
              - pattern: $TYPE $FUNC(..., int $VAR, ...);
              - pattern: $TYPE $FUNC(..., int $VAR, ...) { ... }
          - metavariable-regex:
              metavariable: $VAR
              regex: "^(?!i32[A-Z]).*"

      # 3. Char Pointers (pc)
      - patterns:
          - pattern-either:
              - pattern: $TYPE $FUNC(..., char * $VAR, ...);
              - pattern: $TYPE $FUNC(..., char * $VAR, ...) { ... }
          - metavariable-regex:
              metavariable: $VAR
              regex: "^(?!pc[A-Z]).*"
              
      # --- STATIC & VOID FUNCTIONS ---
      # Matches: static void Function(void* pvParam);
      - patterns:
          - pattern: static void $FUNC(..., void* $VAR, ...);
          - metavariable-regex:
              metavariable: $VAR
              regex: "^(?!pv[A-Z]).*"

      # Matches: void Function(AppCfg eAppCfg);
      - patterns:
          - pattern: $RET $FUNC(..., AppCfg $VAR, ...);
          - metavariable-regex:
              metavariable: $VAR
              # Assuming AppCfg should have an 'e' prefix (for Enum)
              regex: "^(?!e[A-Z]).*"

      # Matches: char* AppConfig_Get(AppCfg appcfg);
      - patterns:
          - pattern: char * $FUNC(..., AppCfg $VAR, ...);
          - metavariable-regex:
              metavariable: $VAR
              regex: "^(?!e[A-Z]).*"

      # --- CUSTOM TYPEDEFS (Enums/Structs) ---
      - patterns:
          - pattern-either:
              - pattern: $RET $FUNC(..., $TYPE $VAR, ...);
              - pattern: $TYPE $VAR;
          # 1. Only look at types that are NOT standard (int, char, etc.)
          - metavariable-regex:
              metavariable: $TYPE
              regex: "^(?!int|char|void|bool|uint|float|double|short|signed|unsigned).*"
          # 2. Enforce a prefix (e.g., 'e' for enum, 's' for struct, or 'pv' for void*)
          - metavariable-regex:
              metavariable: $VAR
              # This regex flags anything that DOES NOT start with e, s, or pv
              regex: "^(?!(e|s|pv)[A-Z]).*"

