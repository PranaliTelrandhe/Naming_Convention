name: Build C Project on Windows

on:
  push:
    branches:
      - master
  pull_request:

jobs:
  build:
    runs-on: [self-hosted, windows]

    steps:
      # 1. Checkout code
      - name: Checkout repository
        uses: actions/checkout@v3

      # 2. Add Tools to PATH
      - name: Add Tools to PATH
        run: |
          echo "C:\msys64\mingw64\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          echo "C:\Program Files\CMake\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          echo "C:\Program Files\LLVM\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
        shell: powershell

      # 3. Run Semgrep Naming Convention Scan
      - name: Run Semgrep Scan
        run: semgrep --config semgrep-naming-rules.yml
        continue-on-error: true

      # 4. Format Code
      - name: Run Clang Format
        run: |
          $files = Get-ChildItem -Path . -Include *.c,*.h -Recurse
          if ($files) {
              $files | ForEach-Object { clang-format -i $_.FullName }
          }
        shell: powershell

      # 5. Generate build files (DYNAMIC PATH VERSION)
      - name: Generate build files with CMake
        run: |
          # Find the actual directory containing CMakeLists.txt
          $cmakeFile = Get-ChildItem -Recurse -Filter "CMakeLists.txt" | Select-Object -First 1

          if (-not $cmakeFile) {
              Write-Error "Could not find CMakeLists.txt anywhere in the workspace!"
              exit 1
          }

          $sourceDir = $cmakeFile.DirectoryName
          Write-Host "Found CMakeLists.txt in: $sourceDir"

          # Clean build folder
          if (Test-Path "build") { 
              Remove-Item -Recurse -Force -ErrorAction SilentlyContinue "build" 
          }

          # Run CMake using the dynamic source directory
          cmake -S "$sourceDir" -B build -G "MinGW Makefiles" `
            -DCMAKE_C_COMPILER=gcc `
            -DCMAKE_CXX_COMPILER=g++ `
            -DCMAKE_EXPORT_COMPILE_COMMANDS=ON
        shell: powershell

      # 6. Build the project
      - name: Build project
        run: |
          # No need to find path here, 'build' folder was created in the root in Step 5
          cmake --build build
        shell: powershell

      # 7. Run Clang-Tidy
      - name: Run Clang-Tidy
        run: |
          $files = Get-ChildItem -Path . -Include *.c,*.h -Recurse
          if ($files) {
              foreach ($file in $files) {
                  Write-Host "Checking: $($file.Name)"
                  # Use -p build so clang-tidy finds compile_commands.json
                  clang-tidy $file.FullName -p build -checks="clang-analyzer-*,bugprone-*" -- -I.
              }
          }
        shell: powershell

      # 8. Run the executable
      - name: Run executable
        run: |
          # Search build folder for the exe
          $exe = Get-ChildItem -Path build -Filter "*.exe" -Recurse | Select-Object -First 1
          if ($exe) {
            Write-Host "Executing: $($exe.FullName)"
            & $exe.FullName
          } else {
            Write-Host "Error: No executable found."
            exit 1
          }
        shell: powershell
